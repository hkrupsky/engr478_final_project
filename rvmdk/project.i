#line 1 "project.c"









#line 1 "hal\\HAL.h"









#line 1 "E:\\Keil\\ARM\\ARMCC\\Bin\\..\\include\\stdint.h"
 
 





 









     
#line 27 "E:\\Keil\\ARM\\ARMCC\\Bin\\..\\include\\stdint.h"
     











#line 46 "E:\\Keil\\ARM\\ARMCC\\Bin\\..\\include\\stdint.h"





 

     

     
typedef   signed          char int8_t;
typedef   signed short     int int16_t;
typedef   signed           int int32_t;
typedef   signed       __int64 int64_t;

     
typedef unsigned          char uint8_t;
typedef unsigned short     int uint16_t;
typedef unsigned           int uint32_t;
typedef unsigned       __int64 uint64_t;

     

     
     
typedef   signed          char int_least8_t;
typedef   signed short     int int_least16_t;
typedef   signed           int int_least32_t;
typedef   signed       __int64 int_least64_t;

     
typedef unsigned          char uint_least8_t;
typedef unsigned short     int uint_least16_t;
typedef unsigned           int uint_least32_t;
typedef unsigned       __int64 uint_least64_t;

     

     
typedef   signed           int int_fast8_t;
typedef   signed           int int_fast16_t;
typedef   signed           int int_fast32_t;
typedef   signed       __int64 int_fast64_t;

     
typedef unsigned           int uint_fast8_t;
typedef unsigned           int uint_fast16_t;
typedef unsigned           int uint_fast32_t;
typedef unsigned       __int64 uint_fast64_t;

     




typedef   signed           int intptr_t;
typedef unsigned           int uintptr_t;


     
typedef   signed     long long intmax_t;
typedef unsigned     long long uintmax_t;




     

     





     





     





     

     





     





     





     

     





     





     





     

     






     






     






     

     


     


     


     

     
#line 216 "E:\\Keil\\ARM\\ARMCC\\Bin\\..\\include\\stdint.h"

     



     






     
    
 



#line 241 "E:\\Keil\\ARM\\ARMCC\\Bin\\..\\include\\stdint.h"

     







     










     











#line 305 "E:\\Keil\\ARM\\ARMCC\\Bin\\..\\include\\stdint.h"






 
#line 11 "hal\\HAL.h"


typedef enum { 
	PORTA = 0, 
	PORTB = 1, 
	PORTC = 2, 
	PORTD = 3, 
	PORTE = 4, 
	PORTF = 5
} PortName_t;	



typedef enum { 
	PIN0 = 0x01,
	PIN1 = 0x02,
	PIN2 = 0x04,
	PIN3 = 0x08,
	PIN4 = 0x10,
	PIN5 = 0x20,
	PIN6 = 0x40,
	PIN7 = 0x80
} PinName_t;	


typedef struct {
	PortName_t		port;
	PinName_t			pin;
}	PinDef_t;





#line 1 "hal\\HAL_NVIC.h"

#line 3 "hal\\HAL_NVIC.h"

void NVIC_EnableIRQ(uint8_t irq, uint8_t priority);
void NVIC_DisableIRQ(uint8_t irq);

#line 46 "hal\\HAL.h"
#line 1 "hal\\HAL_PLL.h"









#line 11 "hal\\HAL_PLL.h"





void PLL_Init80MHz(void);





uint32_t PLL_GetBusClockFreq(void);




#line 47 "hal\\HAL.h"
#line 1 "hal\\HAL_SysTick.h"









#line 11 "hal\\HAL_SysTick.h"





int SysTick_Init(void);





void SysTick_Wait(uint32_t delay);





void SysTick_Wait10ms(uint32_t delay);





void SysTick_Wait10us(uint32_t delay);





#line 48 "hal\\HAL.h"
#line 1 "hal\\HAL_UART.h"









#line 11 "hal\\HAL_UART.h"


typedef void (*PFN_RxCallback)(char c);
	

typedef enum {
	UART0,
	UART1,
	UART2,
	UART3,
	UART4,
	UART5,
	UART6,
	UART7
} UART_ID_t;






int UART_Enable(UART_ID_t uartId, uint32_t baud);






void UART_WriteChar(UART_ID_t uartId, char c);






void UART_WriteString(UART_ID_t uartId, char* sz);






char UART_ReadChar(UART_ID_t uartId);









int UART_EnableRxInterrupt(UART_ID_t uartId, uint8_t priority, PFN_RxCallback callback);




#line 49 "hal\\HAL.h"
#line 1 "hal\\HAL_GPIO.h"










#line 12 "hal\\HAL_GPIO.h"


typedef enum { DRIVE_2MA, DRIVE_4MA, DRIVE_8MA } GPIO_Drive_t;


typedef enum { PULL_NONE, PULL_UP, PULL_DOWN } GPIO_Pull_t;


typedef enum { 
	INT_TRIGGER_NONE, 
	INT_TRIGGER_LOW_LEVEL,
	INT_TRIGGER_HIGH_LEVEL,
	INT_TRIGGER_RISING_EDGE,
	INT_TRIGGER_FALLING_EDGE,
	INT_TRIGGER_BOTH_EDGES
} GPIO_IntTrigger_t;


typedef void (*PFN_GPIOCallback)(uint32_t pinMap);





void GPIO_InitPort(PortName_t port);








void GPIO_EnableDO(PortName_t port, uint8_t pinMap, GPIO_Drive_t drive, GPIO_Pull_t pull);







void GPIO_EnableDI(PortName_t port, uint8_t pinMap, GPIO_Pull_t pull);








void GPIO_EnableAltDigital(PortName_t port, uint8_t pinMap, uint8_t ctl);






void GPIO_EnableAltAnalog(PortName_t port, uint8_t pinMap);





volatile uint32_t* GPIO_GetBitBandIOAddress(const PinDef_t* pinDef);





int GPIO_EnableInterrupt(const PinDef_t* pinDef, uint8_t priority, GPIO_IntTrigger_t trigger, PFN_GPIOCallback callback);





void GPIO_DisarmInterrupt(const PinDef_t* pinDef); 





void GPIO_RearmInterrupt(const PinDef_t* pinDef); 


#line 50 "hal\\HAL.h"
#line 1 "hal\\HAL_ADC.h"









#line 11 "hal\\HAL_ADC.h"


typedef enum {
	AIN0 = 0,
	AIN1 = 1,
	AIN2 = 2,
	AIN3 = 3,
	AIN4 = 4,
	AIN5 = 5,
	AIN6 = 6,
	AIN7 = 7,
	AIN8 = 8,
	AIN9 = 9,
	AIN10 = 10,
	AIN11 = 11
} ADCChannel;


typedef enum {
	ADC0 = 0,
	ADC1 = 1
} ADCModule;


typedef struct {
	ADCModule module;	
	ADCChannel channel;
} AnalogDef_t;










void ADC_Enable(ADCModule module, ADCChannel channel);






uint32_t ADC_Sample(ADCModule module);




#line 51 "hal\\HAL.h"
#line 1 "hal\\HAL_PWM.h"









#line 11 "hal\\HAL_PWM.h"


typedef enum {
	PWM0 = 0,
	PWM1 = 1,
	PWM2 = 2,
	PWM3 = 3,
	PWM4 = 4,
	PWM5 = 5,
	PWM6 = 6,
	PWM7 = 7,
} PWMChannel;


typedef enum {
	PWMModule0 = 0,
	PWMModule1 = 1
} PWMModule;


typedef struct {
	PWMModule module;	
	PWMChannel channel;
} PWMDef_t;








void PWM_SetClockDivisor(uint8_t divisor);









void PWM_Configure(PWMModule module, PWMChannel channel, uint16_t period, uint16_t duty);








void PWM_Enable(PWMModule module, PWMChannel channel);
	





void PWM_Disable(PWMModule module, PWMChannel channel);








void PWM_SetDuty(PWMModule module, PWMChannel channel, uint16_t duty);



#line 52 "hal\\HAL.h"
#line 1 "hal\\HAL_Timer.h"









#line 11 "hal\\HAL_Timer.h"


typedef void (*PFN_TimerCallback)(void);


typedef enum {
	TIMER0 = 0,
	TIMER1 = 1,
	TIMER2 = 2,
	TIMER3 = 3,
	TIMER4 = 4,
	TIMER5 = 5,
} TimerBlock_t;










int Timer_EnableTimerPeriodic(TimerBlock_t block, uint32_t interval, uint8_t priority, PFN_TimerCallback callback);








int Timer_EnableInputCounter(TimerBlock_t block);





void Timer_ResetInputCounter(TimerBlock_t block);





uint32_t Timer_ReadCounterValue(TimerBlock_t block);


#line 53 "hal\\HAL.h"
#line 1 "hal\\HAL_SPI.h"









#line 11 "hal\\HAL_SPI.h"


typedef enum {
	SSI0 = 0,
	SSI1 = 1,
	SSI2 = 2,
	SSI3 = 3
} SSIModule_t;





int SPI_Enable(SSIModule_t module);






void SPI_Write(SSIModule_t module, uint8_t data);

#line 54 "hal\\HAL.h"
#line 1 "hal\\HAL_Flash.h"














void Flash_Enable(void);





int Flash_Erase(int blockCount);






int Flash_Write(const void* data, int wordCount);






void Flash_Read(void* data, int wordCount);

#line 55 "hal\\HAL.h"




#line 11 "project.c"

#line 1 ".\\FreeRTOS\\include\\FreeRTOS.h"


























 






 
#line 1 "E:\\Keil\\ARM\\ARMCC\\Bin\\..\\include\\stddef.h"
 






 

 
 
 





 





#line 34 "E:\\Keil\\ARM\\ARMCC\\Bin\\..\\include\\stddef.h"




  typedef signed int ptrdiff_t;



  



    typedef unsigned int size_t;    
#line 57 "E:\\Keil\\ARM\\ARMCC\\Bin\\..\\include\\stddef.h"



   



      typedef unsigned short wchar_t;  
#line 82 "E:\\Keil\\ARM\\ARMCC\\Bin\\..\\include\\stddef.h"



    




   




  typedef long double max_align_t;









#line 114 "E:\\Keil\\ARM\\ARMCC\\Bin\\..\\include\\stddef.h"



 

#line 36 ".\\FreeRTOS\\include\\FreeRTOS.h"













 
#line 51 ".\\FreeRTOS\\include\\FreeRTOS.h"





 
#line 1 ".\\FreeRTOSConfig.h"


























 














 

extern uint32_t SystemCoreClock;


#line 59 ".\\FreeRTOSConfig.h"













 

#line 83 ".\\FreeRTOSConfig.h"



 










 



 




#line 58 ".\\FreeRTOS\\include\\FreeRTOS.h"

 
#line 1 ".\\FreeRTOS\\include\\projdefs.h"


























 







 
typedef void (*TaskFunction_t)( void * );



 












 




 











 
#line 111 ".\\FreeRTOS\\include\\projdefs.h"


 



 








#line 61 ".\\FreeRTOS\\include\\FreeRTOS.h"

 
#line 1 ".\\FreeRTOS\\include\\portable.h"


























 



 













 
#line 1 ".\\FreeRTOS\\include\\deprecated_definitions.h"


























 












 











































































































































































#line 219 ".\\FreeRTOS\\include\\deprecated_definitions.h"

#line 227 ".\\FreeRTOS\\include\\deprecated_definitions.h"







#line 241 ".\\FreeRTOS\\include\\deprecated_definitions.h"








































#line 47 ".\\FreeRTOS\\include\\portable.h"




 
#line 1 ".\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\portmacro.h"


























 

















 

 
#line 55 ".\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\portmacro.h"

typedef uint32_t StackType_t;
typedef long BaseType_t;
typedef unsigned long UBaseType_t;





	typedef uint32_t TickType_t;


	
 


 

 




 


 

 
#line 94 ".\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\portmacro.h"
 





 

 
extern void vPortEnterCritical( void );
extern void vPortExitCritical( void );

#line 112 ".\\FreeRTOS\\portable\\RVDS\\ARM_CM4F\\portmacro.h"

 

 

	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );


 

 






	 




	 



	 




 



 


 


	void vPortValidateInterruptPriority( void );



 








 

static __forceinline void vPortSetBASEPRI( uint32_t ulBASEPRI )
{
	__asm
	{
		
 
		msr basepri, ulBASEPRI
	}
}
 

static __forceinline void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI = 191;

	__asm
	{
		
 
		msr basepri, ulNewBASEPRI
		dsb
		isb
	}
}
 

static __forceinline void vPortClearBASEPRIFromISR( void )
{
	__asm
	{
		

 
		msr basepri, #0
	}
}
 

static __forceinline uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulReturn, ulNewBASEPRI = 191;

	__asm
	{
		
 
		mrs ulReturn, basepri
		msr basepri, ulNewBASEPRI
		dsb
		isb
	}

	return ulReturn;
}
 

static __forceinline BaseType_t xPortIsInsideInterrupt( void )
{
uint32_t ulCurrentInterrupt;
BaseType_t xReturn;

	 
	__asm
	{
		mrs ulCurrentInterrupt, ipsr
	}

	if( ulCurrentInterrupt == 0 )
	{
		xReturn = ( ( BaseType_t ) 0 );
	}
	else
	{
		xReturn = ( ( BaseType_t ) 1 );
	}

	return xReturn;
}








#line 54 ".\\FreeRTOS\\include\\portable.h"






































#line 1 ".\\FreeRTOS\\include\\mpu_wrappers.h"


























 





 
#line 173 ".\\FreeRTOS\\include\\mpu_wrappers.h"










#line 93 ".\\FreeRTOS\\include\\portable.h"






 



	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;


 
typedef struct HeapRegion
{
	uint8_t *pucStartAddress;
	size_t xSizeInBytes;
} HeapRegion_t;











 
void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;




 
void *pvPortMalloc( size_t xSize ) ;
void vPortFree( void *pv ) ;
void vPortInitialiseBlocks( void ) ;
size_t xPortGetFreeHeapSize( void ) ;
size_t xPortGetMinimumEverFreeHeapSize( void ) ;




 
BaseType_t xPortStartScheduler( void ) ;





 
void vPortEndScheduler( void ) ;







 











#line 64 ".\\FreeRTOS\\include\\FreeRTOS.h"

 




 







 



























































































































































#line 240 ".\\FreeRTOS\\include\\FreeRTOS.h"

 


















































 

	
 




	
 




	
 




	
 




	 




	 




	
 




	



 




	


 




	


 




	


 




	


 















 





















































































































































































































































































































#line 709 ".\\FreeRTOS\\include\\FreeRTOS.h"










































































































	 









	
 



 


















#line 858 ".\\FreeRTOS\\include\\FreeRTOS.h"
	
 







 





	








 




	
 




	
 



#line 918 ".\\FreeRTOS\\include\\FreeRTOS.h"

	
 













 













 
struct xSTATIC_LIST_ITEM
{
	TickType_t xDummy1;
	void *pvDummy2[ 4 ];
};
typedef struct xSTATIC_LIST_ITEM StaticListItem_t;

 
struct xSTATIC_MINI_LIST_ITEM
{
	TickType_t xDummy1;
	void *pvDummy2[ 2 ];
};
typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;

 
typedef struct xSTATIC_LIST
{
	UBaseType_t uxDummy1;
	void *pvDummy2;
	StaticMiniListItem_t xDummy3;
} StaticList_t;













 
typedef struct xSTATIC_TCB
{
	void				*pxDummy1;



	StaticListItem_t	xDummy3[ 2 ];
	UBaseType_t			uxDummy5;
	void				*pxDummy6;
	uint8_t				ucDummy7[ ( 10 ) ];
#line 1020 ".\\FreeRTOS\\include\\FreeRTOS.h"
		uint32_t 		ulDummy18;
		uint8_t 		ucDummy19;






		uint8_t ucDummy21;


} StaticTask_t;














 
typedef struct xSTATIC_QUEUE
{
	void *pvDummy1[ 3 ];

	union
	{
		void *pvDummy2;
		UBaseType_t uxDummy2;
	} u;

	StaticList_t xDummy3[ 2 ];
	UBaseType_t uxDummy4[ 3 ];
	uint8_t ucDummy5[ 2 ];














} StaticQueue_t;
typedef StaticQueue_t StaticSemaphore_t;














 
typedef struct xSTATIC_EVENT_GROUP
{
	TickType_t xDummy1;
	StaticList_t xDummy2;









} StaticEventGroup_t;














 
typedef struct xSTATIC_TIMER
{
	void				*pvDummy1;
	StaticListItem_t	xDummy2;
	TickType_t			xDummy3;
	UBaseType_t			uxDummy4;
	void 				*pvDummy5[ 2 ];








} StaticTimer_t;














 
typedef struct xSTATIC_STREAM_BUFFER
{
	size_t uxDummy1[ 4 ];
	void * pvDummy2[ 3 ];
	uint8_t ucDummy3;



} StaticStreamBuffer_t;

 
typedef StaticStreamBuffer_t StaticMessageBuffer_t;







#line 13 "project.c"
#line 1 ".\\FreeRTOS\\include\\task.h"


























 









#line 1 ".\\FreeRTOS\\include\\list.h"


























 



























 



































 












 

	 
#line 135 ".\\FreeRTOS\\include\\list.h"




 
struct xLIST_ITEM
{
				 
	 TickType_t xItemValue;			 
	struct xLIST_ITEM *  pxNext;		 
	struct xLIST_ITEM *  pxPrevious;	 
	void * pvOwner;										 
	void *  pvContainer;				 
				 
};
typedef struct xLIST_ITEM ListItem_t;					 

struct xMINI_LIST_ITEM
{
				 
	 TickType_t xItemValue;
	struct xLIST_ITEM *  pxNext;
	struct xLIST_ITEM *  pxPrevious;
};
typedef struct xMINI_LIST_ITEM MiniListItem_t;



 
typedef struct xLIST
{
					 
	volatile UBaseType_t uxNumberOfItems;
	ListItem_t *  pxIndex;			 
	MiniListItem_t xListEnd;							 
					 
} List_t;







 








 








 









 








 







 







 







 








 




 





















 
#line 289 ".\\FreeRTOS\\include\\list.h"

















 










 







 






 











 
void vListInitialise( List_t * const pxList ) ;









 
void vListInitialiseItem( ListItem_t * const pxItem ) ;











 
void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) ;



















 
void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) ;













 
UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;







#line 38 ".\\FreeRTOS\\include\\task.h"







 















 
typedef void * TaskHandle_t;




 
typedef BaseType_t (*TaskHookFunction_t)( void * );

 
typedef enum
{
	eRunning = 0,	 
	eReady,			 
	eBlocked,		 
	eSuspended,		 
	eDeleted,		 
	eInvalid			 
} eTaskState;

 
typedef enum
{
	eNoAction = 0,				 
	eSetBits,					 
	eIncrement,					 
	eSetValueWithOverwrite,		 
	eSetValueWithoutOverwrite	 
} eNotifyAction;



 
typedef struct xTIME_OUT
{
	BaseType_t xOverflowCount;
	TickType_t xTimeOnEntering;
} TimeOut_t;



 
typedef struct xMEMORY_REGION
{
	void *pvBaseAddress;
	uint32_t ulLengthInBytes;
	uint32_t ulParameters;
} MemoryRegion_t;



 
typedef struct xTASK_PARAMETERS
{
	TaskFunction_t pvTaskCode;
	const char * const pcName;	 
	uint16_t usStackDepth;
	void *pvParameters;
	UBaseType_t uxPriority;
	StackType_t *puxStackBuffer;
	MemoryRegion_t xRegions[ 1 ];



} TaskParameters_t;


 
typedef struct xTASK_STATUS
{
	TaskHandle_t xHandle;			 
	const char *pcTaskName;			   
	UBaseType_t xTaskNumber;		 
	eTaskState eCurrentState;		 
	UBaseType_t uxCurrentPriority;	 
	UBaseType_t uxBasePriority;		 
	uint32_t ulRunTimeCounter;		 
	StackType_t *pxStackBase;		 
	uint16_t usStackHighWaterMark;	 
} TaskStatus_t;

 
typedef enum
{
	eAbortSleep = 0,		 
	eStandardSleep,			 
	eNoTasksWaitingTimeout	 
} eSleepModeStatus;





 









 













 














 









 









 




 







 





























































































 

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
							const char * const pcName,	 
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) ;












































































































 
#line 446 ".\\FreeRTOS\\include\\task.h"








































































 























































































 

















































 
void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;







































 
void vTaskDelete( TaskHandle_t xTaskToDelete ) ;



 














































 
void vTaskDelay( const TickType_t xTicksToDelay ) ;

























































 
void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;























 
BaseType_t xTaskAbortDelay( TaskHandle_t xTask ) ;













































 
UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;






 
UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) ;
















 
eTaskState eTaskGetState( TaskHandle_t xTask ) ;






















































 
void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) ;








































 
void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;

















































 
void vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;















































 
void vTaskResume( TaskHandle_t xTaskToResume ) ;



























 
BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;



 



























 
void vTaskStartScheduler( void ) ;






















































 
void vTaskEndScheduler( void ) ;

















































 
void vTaskSuspendAll( void ) ;




















































 
BaseType_t xTaskResumeAll( void ) ;



 









 
TickType_t xTaskGetTickCount( void ) ;














 
TickType_t xTaskGetTickCountFromISR( void ) ;












 
UBaseType_t uxTaskGetNumberOfTasks( void ) ;











 
char *pcTaskGetName( TaskHandle_t xTaskToQuery ) ;  














 
TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) ;  



















 
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;






 
#line 1452 ".\\FreeRTOS\\include\\task.h"

#line 1464 ".\\FreeRTOS\\include\\task.h"











 
BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;







 
TaskHandle_t xTaskGetIdleTaskHandle( void ) ;

































































































 
UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) ;













































 
void vTaskList( char * pcWriteBuffer ) ;  




















































 
void vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  















































































 
BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ;

























































































 
BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ;











































































 
BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ;












































 






















































 
void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ;



































































 
uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ;














 
BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );



 















 
BaseType_t xTaskIncrementTick( void ) ;































 
void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;











 
void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
























 
BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;








 
void vTaskSwitchContext( void ) ;




 
TickType_t uxTaskResetEventItemValue( void ) ;



 
TaskHandle_t xTaskGetCurrentTaskHandle( void ) ;



 
void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;




 
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;




 
void vTaskMissedYield( void ) ;




 
BaseType_t xTaskGetSchedulerState( void ) ;




 
BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;




 
BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;








 
void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask ) ;



 
UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;




 
void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;








 
void vTaskStepTick( const TickType_t xTicksToJump ) ;














 
eSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;




 
void *pvTaskIncrementMutexHeldCount( void ) ;




 
void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut ) ;









#line 14 "project.c"
#line 1 ".\\FreeRTOS\\include\\semphr.h"


























 








#line 1 ".\\FreeRTOS\\include\\queue.h"


























 


















 
typedef void * QueueHandle_t;





 
typedef void * QueueSetHandle_t;





 
typedef void * QueueSetMemberHandle_t;

 




 
#line 75 ".\\FreeRTOS\\include\\queue.h"




































































 





















































































 

















































































 

















































































 



















































































 


















































































 























































































 
BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ;




























































































 
BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) ;































 
BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) ;

























































































 
BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) ;













 
UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;















 
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;












 
void vQueueDelete( QueueHandle_t xQueue ) ;




































































 






































































 






















































































 









































































 














































































 
BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ;
BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) ;























































































 
BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) ;




 
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;









 
BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );





 
QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) ;
QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) ;
QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) ;
BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait ) ;
void* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;
void* xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore ) ;




 
BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) ;
BaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;




 























 













 














 








 

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) ;






 



















































 
QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;






















 
BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;

















 
BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;


































 
QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) ;



 
QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;

 
void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) ;
void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) ;
UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
uint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;








#line 37 ".\\FreeRTOS\\include\\semphr.h"

typedef QueueHandle_t SemaphoreHandle_t;






















































 
#line 104 ".\\FreeRTOS\\include\\semphr.h"

























































 


























































 




































































 




























































































 
































































 



















































































 




























































































 

































 
























































 




























































 



































































 








































































 















































































 




















































































 















 














 










 











 





#line 15 "project.c"
#line 1 ".\\FreeRTOS\\include\\timers.h"


























 










 
#line 40 ".\\FreeRTOS\\include\\timers.h"
 







 





 
#line 63 ".\\FreeRTOS\\include\\timers.h"













 
typedef void * TimerHandle_t;



 
typedef void (*TimerCallbackFunction_t)( TimerHandle_t xTimer );




 
typedef void (*PendedFunction_t)( void *, uint32_t );









































































































































 

	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			 
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction ) ;



























































































































 
#line 365 ".\\FreeRTOS\\include\\timers.h"




















 
void *pvTimerGetTimerID( const TimerHandle_t xTimer ) ;



















 
void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ) ;



































 
BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer ) ;






 
TaskHandle_t xTimerGetTimerDaemonTaskHandle( void ) ;


















































 









































 















































































 





































 



























































































































 





















































































 






























































 








































































 





















































































 


























































































 
BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken ) ;

 






























 
BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait ) ;









 
const char * pcTimerGetName( TimerHandle_t xTimer ) ;  









 
TickType_t xTimerGetPeriod( TimerHandle_t xTimer ) ;













 
TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer ) ;




 
BaseType_t xTimerCreateTimerTask( void ) ;
BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) ;













#line 16 "project.c"
#line 1 "midi.h"


#line 4 "midi.h"

typedef enum {
	MIDI_C0		=	12,
	MIDI_CS0	=	13,
	MIDI_D0		=	14,
	MIDI_DS0	=	15,
	MIDI_E0		=	16,
	MIDI_F0		=	17,
	MIDI_FS0	=	18,
	MIDI_G0		=	19,
	MIDI_GS0	=	20,
	MIDI_A0		=	21,
	MIDI_AS0	=	22,
	MIDI_B0		=	23,
	MIDI_C1		=	24,
	MIDI_CS1	=	25,
	MIDI_D1		=	26,
	MIDI_DS1	=	27,
	MIDI_E1		=	28,
	MIDI_F1		=	29,
	MIDI_FS1	=	30,
	MIDI_G1		=	31,
	MIDI_GS1	=	32,
	MIDI_A1		=	33,
	MIDI_AS1	=	34,
	MIDI_B1		=	35,
	MIDI_C2		=	36,
	MIDI_CS2	=	37,
	MIDI_D2		=	38,
	MIDI_DS2	=	39,
	MIDI_E2		=	40,
	MIDI_F2		=	41,
	MIDI_FS2	=	42,
	MIDI_G2		=	43,
	MIDI_GS2	=	44,
	MIDI_A2		=	45,
	MIDI_AS2	=	46,
	MIDI_B2		=	47,
	MIDI_C3		=	48,
	MIDI_CS3	=	49,
	MIDI_D3		=	50,
	MIDI_DS3	=	51,
	MIDI_E3		=	52,
	MIDI_F3		=	53,
	MIDI_FS3	=	54,
	MIDI_G3		=	55,
	MIDI_GS3	=	56,
	MIDI_A3		=	57,
	MIDI_AS3	=	58,
	MIDI_B3		=	59,
	MIDI_C4		=	60,
	MIDI_CS4	=	61,
	MIDI_D4		=	62,
	MIDI_DS4	=	63,
	MIDI_E4		=	64,
	MIDI_F4		=	65,
	MIDI_FS4	=	66,
	MIDI_G4		=	67,
	MIDI_GS4	=	68,
	MIDI_A4		=	69,
	MIDI_AS4	=	70,
	MIDI_B4		=	71,
	MIDI_C5		=	72,
	MIDI_CS5	=	73,
	MIDI_D5		=	74,
	MIDI_DS5	=	75,
	MIDI_E5		=	76,
	MIDI_F5		=	77,
	MIDI_FS5	=	78,
	MIDI_G5		=	79,
	MIDI_GS5	=	80,
	MIDI_A5		=	81,
	MIDI_AS5	=	82,
	MIDI_B5		=	83,
	MIDI_C6		=	84,
	MIDI_CS6	=	85,
	MIDI_D6		=	86,
	MIDI_DS6	=	87,
	MIDI_E6		=	88,
	MIDI_F6		=	89,
	MIDI_FS6	=	90,
	MIDI_G6		=	91,
	MIDI_GS6	=	92,
	MIDI_A6		=	93,
	MIDI_AS6	=	94,
	MIDI_B6		=	95,
	MIDI_C7		=	96,
	MIDI_CS7	=	97,
	MIDI_D7		=	98,
	MIDI_DS7	=	99,
	MIDI_E7		=	100,
	MIDI_F7		=	101,
	MIDI_FS7	=	102,
	MIDI_G7		=	103,
	MIDI_GS7	=	104,
	MIDI_A7		=	105,
	MIDI_AS7	=	106,
	MIDI_B7		=	107,
	MIDI_C8		=	108,
	MIDI_CS8	=	109,
	MIDI_D8		=	110,
	MIDI_DS8	=	111,
	MIDI_E8		=	112,
	MIDI_F8		=	113,
	MIDI_FS8	=	114,
	MIDI_G8		=	115,
	MIDI_GS8	=	116,
	MIDI_A8		=	117,
	MIDI_AS8	=	118,
	MIDI_B8		=	119

} MidiNotes_t;

typedef enum MidiEventStatus
{
	NOTE_ON = 0x90,
	NOTE_OFF = 0x80
} EventStatus_t;

typedef struct MidiNoteEvent
{
	int16_t deltaTime;
	uint8_t	status;
	uint8_t key;
	uint8_t velocity;
} MidiNoteEvent_t;

typedef struct  
{
	const MidiNoteEvent_t* notes;
} MidiTrack_t;


typedef struct 
{
	int	numTracks;
	const MidiTrack_t* tracks;
} MidiFile_t;


extern const uint16_t Midi_NotePwmPeriods[]; 

		
#line 17 "project.c"




uint32_t SystemCoreClock;

static SemaphoreHandle_t playSemaphore_;
static SemaphoreHandle_t trackSemaphore_;
static uint8_t switchPressed_;

extern MidiFile_t midi_tune;

typedef struct {
	TaskHandle_t taskHandle;
	PWMModule pwmModule; 
	PWMChannel pwmChannel;
	const MidiTrack_t* track;
	uint8_t isPlaying;
} TrackParams_t;




static TrackParams_t trackParams_[4] = { 
	{ 0, PWMModule0, PWM0, 0, 0 },
	{ 0, PWMModule0, PWM3, 0, 0 },
	{ 0, PWMModule0, PWM4, 0, 0 },
	{ 0, PWMModule1, PWM3, 0, 0 }
};



static void ErrHandler(void)
{
	while (1) {}
}


static void PlayNote(const MidiNoteEvent_t* note, PWMModule pwmModule, PWMChannel pwmChannel)
{
	
	if (note->key == 0 || note->velocity == 0) {
		PWM_Disable(pwmModule, pwmChannel);
	}
	else {
	
		
		uint16_t period = Midi_NotePwmPeriods[note->key];
		uint16_t duty = period / 2;
		
		PWM_Configure(pwmModule, pwmChannel, period, duty);
		PWM_Enable(pwmModule, pwmChannel);
	}
}

void SwitchHandler(uint32_t pinMap)
{
	
	
	GPIO_DisarmInterrupt(&((PinDef_t){ PORTF, (PinName_t)(PIN0 | PIN4) }));
	
	
	switchPressed_ = (uint8_t)pinMap;
	
	
	
	BaseType_t xHigherPriorityTaskWoken = ( ( BaseType_t ) 0 );
	
	
	xQueueGiveFromISR( ( QueueHandle_t ) ( playSemaphore_ ), ( &xHigherPriorityTaskWoken ) );
	
	
	
	if( xHigherPriorityTaskWoken != ( ( BaseType_t ) 0 ) ) { ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };

}

int IsPlaying()
{
	
	uint8_t isPlaying = 0;
	for (int i = 0; i < midi_tune.numTracks; i++ ) {		
		isPlaying |= trackParams_[i].isPlaying;
	}
	return isPlaying;
}

void vSwitchTask(void *pvParameters)
{
	TickType_t debounceDelay = ( ( TickType_t ) ( ( ( TickType_t ) ( 250 ) * ( TickType_t ) ( ( TickType_t ) 1000 ) ) / ( TickType_t ) 1000 ) );
	
	for (;;) {
		
		
		BaseType_t taken = xQueueSemaphoreTake( ( playSemaphore_ ), ( ( TickType_t ) 0xffffffffUL ) );
		if (taken == ( ( ( BaseType_t ) 1 ) )) {
			
			
			if (switchPressed_ & PIN4) {
			
				
				if (!IsPlaying()) {
					for (int i = 0; i < midi_tune.numTracks; i++ ) {		
						trackParams_[i].isPlaying = 1;
						xQueueGenericSend( ( QueueHandle_t ) ( trackSemaphore_ ), 0, ( ( TickType_t ) 0U ), ( ( BaseType_t ) 0 ) );
					}
				}
				else {
					for (int i = 0; i < midi_tune.numTracks; i++ ) {	
						trackParams_[i].isPlaying = 0;
						xTaskAbortDelay(trackParams_[i].taskHandle);
					}
				}			
			}
		
			
			vTaskDelay(debounceDelay);
	
			
			GPIO_RearmInterrupt(&((PinDef_t){ PORTF, (PinName_t)(PIN0 | PIN4) }));
				
		}
		
	}
	
}

void vTrackTask(void *pvParameters)
{
	TrackParams_t* params = (TrackParams_t*)pvParameters;

	for (;;) {
		
		
		BaseType_t taken = xQueueSemaphoreTake( ( trackSemaphore_ ), ( ( TickType_t ) 0xffffffffUL ) );
		if (taken == ( ( ( BaseType_t ) 1 ) )) {
		
			TickType_t xLastWakeTime = xTaskGetTickCount();
			
			const MidiNoteEvent_t* notes = params->track->notes;
			
			
			
			for (int noteIndex = 0; notes[noteIndex].deltaTime != -1; noteIndex++) {

				int deltaTime = notes[noteIndex].deltaTime;
				if (deltaTime != 0) {
					
					
					vTaskDelayUntil(&xLastWakeTime, ( ( TickType_t ) ( ( ( TickType_t ) ( deltaTime ) * ( TickType_t ) ( ( TickType_t ) 1000 ) ) / ( TickType_t ) 1000 ) ));	
					
					
					if (!params->isPlaying) {
						break;
					}
				}
					
				
				uint8_t status = 0xF0 & notes[noteIndex].status;
				switch (status) {
					
					case NOTE_ON:
						PlayNote(&notes[noteIndex], params->pwmModule, params->pwmChannel);
						break;

					case NOTE_OFF:
					default:
						PWM_Disable(params->pwmModule, params->pwmChannel);
						break;
				}

			}
			
			
			PWM_Disable(params->pwmModule, params->pwmChannel);
			
			
			
			
			params->isPlaying = 0;
			
		}
	
	}
	
}



static int InitHardware(void)
{
	__disable_irq();
	
	PLL_Init80MHz();

	
	SystemCoreClock = PLL_GetBusClockFreq();

	
	GPIO_EnableDI(PORTF, PIN0 | PIN4, PULL_UP);
	
	
	GPIO_EnableInterrupt(&((PinDef_t){ PORTF, PIN0 }), 7, INT_TRIGGER_FALLING_EDGE, SwitchHandler);
	GPIO_EnableInterrupt(&((PinDef_t){ PORTF, PIN4 }), 7, INT_TRIGGER_FALLING_EDGE, SwitchHandler);
	
	
	
	PWM_SetClockDivisor(64);
	
	__enable_irq();
	
	return 0;
	
}


int main()
{

	if (InitHardware() < 0) {
		ErrHandler();
	}
	
	playSemaphore_ = xQueueGenericCreate( ( UBaseType_t ) 1, ( ( uint8_t ) 0U ), ( ( uint8_t ) 3U ) );
	trackSemaphore_ = xQueueCreateCountingSemaphore( ( 4 ), ( 0 ) );
	
	if (playSemaphore_ && trackSemaphore_) {
			
		
		xTaskCreate(vSwitchTask, "Switch Task", 100, 0, 2, 0);
		
		for (int i = 0; i < midi_tune.numTracks && i < 4; i++ ) {		
			trackParams_[i].track = &midi_tune.tracks[i];
			xTaskCreate(vTrackTask, "Track Task", 100, &trackParams_[i], 1, &trackParams_[i].taskHandle);
		}	
		
		
		vTaskStartScheduler();
	
	}	
		
	
	
	for (;;);

}
